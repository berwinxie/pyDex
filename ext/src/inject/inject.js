var items = [{"name": ["abs"], "description": ["Return the absolute value of a number.  The argument may be a plain or long  integer or a floating point number.  If the argument is a complex number, its  magnitude is returned.   "]},
{"name": ["all"], "description": ["Return  True  if all elements of the  iterable  are true (or if the iterable  is empty).  Equivalent to:    def   all ( iterable ):        for   element   in   iterable :            if   not   element :                return   False        return   True             New in version 2.5.      "]},
{"name": ["any"], "description": ["Return  True  if any element of the  iterable  is true.  If the iterable  is empty, return  False .  Equivalent to:    def   any ( iterable ):        for   element   in   iterable :            if   element :                return   True        return   False             New in version 2.5.      "]},
{"name": ["basestring"], "description": ["This abstract type is the superclass for  str  and  unicode . It  cannot be called or instantiated, but it can be used to test whether an object  is an instance of  str  or  unicode .  isinstance(obj,    basestring)  is equivalent to  isinstance(obj,   (str,   unicode)) .       New in version 2.3.      "]},
{"name": ["bin"], "description": ["Convert an integer number to a binary string. The result is a valid Python  expression.  If  x  is not a Python  int  object, it has to define an   __index__()  method that returns an integer.       New in version 2.6.      "]},
{"name": ["bool"], "description": ["Return a Boolean value, i.e. one of  True  or  False .   x  is converted  using the standard truth testing procedure.  If  x  is false or omitted, this  returns  False ; otherwise it returns  True .  bool  is  also a class, which is a subclass of  int . Class  bool  cannot  be subclassed further.  Its only instances are  False  and   True .       New in version 2.2.1.          Changed in version 2.3:  If no argument is given, this function returns  False .      "]},
{"name": ["bytearray"], "description": ["Return a new array of bytes.  The  bytearray  class is a mutable  sequence of integers in the range 0 <= x < 256.  It has most of the usual  methods of mutable sequences, described in  Mutable Sequence Types , as well  as most methods that the  str  type has, see  String Methods .    The optional  source  parameter can be used to initialize the array in a few  different ways:    If it is  unicode , you must also give the  encoding  (and optionally,   errors ) parameters;  bytearray()  then converts the unicode to  bytes using  unicode.encode() .    If it is an  integer , the array will have that size and will be  initialized with null bytes.    If it is an object conforming to the  buffer  interface, a read-only buffer  of the object will be used to initialize the bytes array.    If it is an  iterable , it must be an iterable of integers in the range   0   <=   x   <   256 , which are used as the initial contents of the array.    Without an argument, an array of size 0 is created.       New in version 2.6.      "]},
{"name": ["callable"], "description": ["Return  True  if the  object  argument appears callable,   False  if not.  If this  returns true, it is still possible that a call fails, but if it is false,  calling  object  will never succeed.  Note that classes are callable (calling a  class returns a new instance); class instances are callable if they have a   __call__()  method.   "]},
{"name": ["chr"], "description": ["Return a string of one character whose ASCII code is the integer  i .  For  example,  chr(97)  returns the string  'a' . This is the inverse of   ord() .  The argument must be in the range [0..255], inclusive;   ValueError  will be raised if  i  is outside that range. See  also  unichr() .   "]},
{"name": ["classmethod"], "description": ["Return a class method for  function .    A class method receives the class as implicit first argument, just like an  instance method receives the instance. To declare a class method, use this  idiom:    class   C ( object ):        @classmethod        def   f ( cls ,   arg1 ,   arg2 ,   ... ):            ...          The  @classmethod  form is a function  decorator  - see the description  of function definitions in  Function definitions  for details.    It can be called either on the class (such as  C.f() ) or on an instance (such  as  C().f() ).  The instance is ignored except for its class. If a class  method is called for a derived class, the derived class object is passed as the  implied first argument.    Class methods are different than C++ or Java static methods. If you want those,  see  staticmethod()  in this section.    For more information on class methods, consult the documentation on the standard  type hierarchy in  The standard type hierarchy .       New in version 2.2.          Changed in version 2.4:  Function decorator syntax added.      "]},
{"name": ["cmp"], "description": ["Compare the two objects  x  and  y  and return an integer according to the  outcome.  The return value is negative if  x   <   y , zero if  x   ==   y  and  strictly positive if  x   >   y .   "]},
{"name": ["compile"], "description": ["Compile the  source  into a code or AST object.  Code objects can be executed  by an  exec  statement or evaluated by a call to  eval() .   source  can either be a Unicode string, a  Latin-1  encoded string or an  AST object.  Refer to the  ast  module documentation for information on how to work  with AST objects.    The  filename  argument should give the file from which the code was read;  pass some recognizable value if it wasn't read from a file ( '<string>'  is  commonly used).    The  mode  argument specifies what kind of code must be compiled; it can be   'exec'  if  source  consists of a sequence of statements,  'eval'  if it  consists of a single expression, or  'single'  if it consists of a single  interactive statement (in the latter case, expression statements that  evaluate to something other than  None  will be printed).    The optional arguments  flags  and  dont_inherit  control which future  statements (see  PEP 236 ) affect the compilation of  source .  If neither  is present (or both are zero) the code is compiled with those future  statements that are in effect in the code that is calling  compile() .  If the   flags  argument is given and  dont_inherit  is not (or is zero) then the  future statements specified by the  flags  argument are used in addition to  those that would be used anyway. If  dont_inherit  is a non-zero integer then  the  flags  argument is it \u2013 the future statements in effect around the call  to compile are ignored.    Future statements are specified by bits which can be bitwise ORed together to  specify multiple statements.  The bitfield required to specify a given feature  can be found as the  compiler_flag  attribute on  the  _Feature  instance in the  __future__  module.    This function raises  SyntaxError  if the compiled source is invalid,  and  TypeError  if the source contains null bytes.    If you want to parse Python code into its AST representation, see   ast.parse() .       Note    When compiling a string with multi-line code in  'single'  or   'eval'  mode, input must be terminated by at least one newline  character.  This is to facilitate detection of incomplete and complete  statements in the  code  module.          Changed in version 2.3:  The  flags  and  dont_inherit  arguments were added.          Changed in version 2.6:  Support for compiling AST objects.          Changed in version 2.7:  Allowed use of Windows and Mac newlines.  Also input in  'exec'  mode  does not have to end in a newline anymore.      "]},
{"name": ["complex"], "description": ["Return a complex number with the value  real  +  imag *j or convert a string or  number to a complex number.  If the first parameter is a string, it will be  interpreted as a complex number and the function must be called without a second  parameter.  The second parameter can never be a string. Each argument may be any  numeric type (including complex). If  imag  is omitted, it defaults to zero and  the function serves as a numeric conversion function like  int() ,   long()  and  float() .  If both arguments are omitted, returns  0j .       Note    When converting from a string, the string must not contain whitespace  around the central  +  or  -  operator.  For example,   complex('1+2j')  is fine, but  complex('1   +   2j')  raises   ValueError .       The complex type is described in  Numeric Types -- int, float, long, complex .   "]},
{"name": ["delattr"], "description": ["This is a relative of  setattr() .  The arguments are an object and a  string.  The string must be the name of one of the object's attributes.  The  function deletes the named attribute, provided the object allows it.  For  example,  delattr(x,   'foobar')  is equivalent to  del   x.foobar .   "]},
{"name": ["dict"], "description": ["Create a new dictionary.  The  dict  object is the dictionary class.  See  dict  and  Mapping Types -- dict  for documentation about this class.    For other containers see the built-in  list ,  set , and   tuple  classes, as well as the  collections  module.   "]},
{"name": ["dir"], "description": ["Without arguments, return the list of names in the current local scope.  With an  argument, attempt to return a list of valid attributes for that object.    If the object has a method named  __dir__() , this method will be called and  must return the list of attributes. This allows objects that implement a custom   __getattr__()  or  __getattribute__()  function to customize the way   dir()  reports their attributes.    If the object does not provide  __dir__() , the function tries its best to  gather information from the object's  __dict__  attribute, if defined, and  from its type object.  The resulting list is not necessarily complete, and may  be inaccurate when the object has a custom  __getattr__() .    The default  dir()  mechanism behaves differently with different types of  objects, as it attempts to produce the most relevant, rather than complete,  information:    If the object is a module object, the list contains the names of the module's  attributes.    If the object is a type or class object, the list contains the names of its  attributes, and recursively of the attributes of its bases.    Otherwise, the list contains the object's attributes' names, the names of its  class's attributes, and recursively of the attributes of its class's base  classes.    The resulting list is sorted alphabetically.  For example:    >>>  import   struct    >>>  dir ()     # show the names in the module namespace    ['__builtins__', '__doc__', '__name__', 'struct']    >>>  dir ( struct )     # show the names in the struct module    ['Struct', '__builtins__', '__doc__', '__file__', '__name__',     '__package__', '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',     'unpack', 'unpack_from']    >>>  class   Shape ( object ):            def __dir__(self):                return ['area', 'perimeter', 'location']    >>>  s   =   Shape ()    >>>  dir ( s )    ['area', 'perimeter', 'location']             Note    Because  dir()  is supplied primarily as a convenience for use at an  interactive prompt, it tries to supply an interesting set of names more than it  tries to supply a rigorously or consistently defined set of names, and its  detailed behavior may change across releases.  For example, metaclass attributes  are not in the result list when the argument is a class.      "]},
{"name": ["divmod"], "description": ["Take two (non complex) numbers as arguments and return a pair of numbers  consisting of their quotient and remainder when using long division.  With mixed  operand types, the rules for binary arithmetic operators apply.  For plain and  long integers, the result is the same as  (a   //   b,   a   %   b) . For floating point  numbers the result is  (q,   a   %   b) , where  q  is usually  math.floor(a   /   b)   but may be 1 less than that.  In any case  q   *   b   +   a   %   b  is very close to   a , if  a   %   b  is non-zero it has the same sign as  b , and  0   <=   abs(a   %   b)    <   abs(b) .       Changed in version 2.3:  Using  divmod()  with complex numbers is deprecated.      "]},
{"name": ["enumerate"], "description": ["Return an enumerate object.  sequence  must be a sequence, an   iterator , or some other object which supports iteration.  The   next()  method of the iterator returned by  enumerate()  returns a  tuple containing a count (from  start  which defaults to 0) and the  values obtained from iterating over  sequence :    >>>  seasons   =   [ 'Spring' ,   'Summer' ,   'Fall' ,   'Winter' ]    >>>  list ( enumerate ( seasons ))    [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]    >>>  list ( enumerate ( seasons ,   start = 1 ))    [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]          Equivalent to:    def   enumerate ( sequence ,   start = 0 ):        n   =   start        for   elem   in   sequence :            yield   n ,   elem            n   +=   1             New in version 2.3.          Changed in version 2.6:  The  start  parameter was added.      "]},
{"name": ["eval"], "description": ["The arguments are a Unicode or  Latin-1  encoded string and optional  globals and locals.  If provided,  globals  must be a dictionary.  If provided,  locals  can be any mapping object.       Changed in version 2.4:  formerly  locals  was required to be a dictionary.       The  expression  argument is parsed and evaluated as a Python expression  (technically speaking, a condition list) using the  globals  and  locals   dictionaries as global and local namespace.  If the  globals  dictionary is  present and lacks '__builtins__', the current globals are copied into  globals   before  expression  is parsed.  This means that  expression  normally has full  access to the standard  __builtin__  module and restricted environments are  propagated.  If the  locals  dictionary is omitted it defaults to the  globals   dictionary.  If both dictionaries are omitted, the expression is executed in the  environment where  eval()  is called.  The return value is the result of  the evaluated expression. Syntax errors are reported as exceptions.  Example:    >>>  x   =   1    >>>  print   eval ( 'x+1' )    2          This function can also be used to execute arbitrary code objects (such as  those created by  compile() ).  In this case pass a code object instead  of a string.  If the code object has been compiled with  'exec'  as the   mode  argument,  eval() 's return value will be  None .    Hints: dynamic execution of statements is supported by the  exec   statement.  Execution of statements from a file is supported by the   execfile()  function.  The  globals()  and  locals()  functions  returns the current global and local dictionary, respectively, which may be  useful to pass around for use by  eval()  or  execfile() .    See  ast.literal_eval()  for a function that can safely evaluate strings  with expressions containing only literals.   "]},
{"name": ["execfile"], "description": ["This function is similar to the  exec  statement, but parses a file  instead of a string.  It is different from the  import  statement in  that it does not use the module administration -- it reads the file  unconditionally and does not create a new module.  [1]    The arguments are a file name and two optional dictionaries.  The file is parsed  and evaluated as a sequence of Python statements (similarly to a module) using  the  globals  and  locals  dictionaries as global and local namespace. If  provided,  locals  can be any mapping object.  Remember that at module level,  globals and locals are the same dictionary. If two separate objects are  passed as  globals  and  locals , the code will be executed as if it were  embedded in a class definition.       Changed in version 2.4:  formerly  locals  was required to be a dictionary.       If the  locals  dictionary is omitted it defaults to the  globals  dictionary.  If both dictionaries are omitted, the expression is executed in the environment  where  execfile()  is called.  The return value is  None .       Note    The default  locals  act as described for function  locals()  below:  modifications to the default  locals  dictionary should not be attempted.  Pass  an explicit  locals  dictionary if you need to see effects of the code on   locals  after function  execfile()  returns.   execfile()  cannot be  used reliably to modify a function's locals.      "]},
{"name": ["file"], "description": ["Constructor function for the  file  type, described further in section   File Objects .  The constructor's arguments are the same as those  of the  open()  built-in function described below.    When opening a file, it's preferable to use  open()  instead of  invoking  this constructor directly.   file  is more suited to type testing (for  example, writing  isinstance(f,   file) ).       New in version 2.2.      "]},
{"name": ["filter"], "description": ["Construct a list from those elements of  iterable  for which  function  returns  true.   iterable  may be either a sequence, a container which supports  iteration, or an iterator.  If  iterable  is a string or a tuple, the result  also has that type; otherwise it is always a list.  If  function  is  None ,  the identity function is assumed, that is, all elements of  iterable  that are  false are removed.    Note that  filter(function,   iterable)  is equivalent to  [item   for   item   in    iterable   if   function(item)]  if function is not  None  and  [item   for   item    in   iterable   if   item]  if function is  None .    See  itertools.ifilter()  and  itertools.ifilterfalse()  for iterator  versions of this function, including a variation that filters for elements  where the  function  returns false.   "]},
{"name": ["float"], "description": ["Return a floating point number constructed from a number or string  x .    If the argument is a string, it  must contain a possibly signed decimal or floating point number, possibly  embedded in whitespace. The argument may also be [+|-]nan or [+|-]inf.  Otherwise, the argument may be a plain or long integer  or a floating point number, and a floating point number with the same value  (within Python's floating point precision) is returned.  If no argument is  given, returns  0.0 .       Note    When passing in a string, values for NaN and Infinity may be returned, depending  on the underlying C library.  Float accepts the strings nan, inf and -inf for  NaN and positive or negative infinity. The case and a leading + are ignored as  well as a leading - is ignored for NaN. Float always represents NaN and infinity  as nan, inf or -inf.       The float type is described in  Numeric Types -- int, float, long, complex .   "]},
{"name": ["format"], "description": ["Convert a  value  to a \"formatted\" representation, as controlled by   format_spec .  The interpretation of  format_spec  will depend on the type  of the  value  argument, however there is a standard formatting syntax that  is used by most built-in types:  Format Specification Mini-Language .       Note    format(value,   format_spec)  merely calls   value.__format__(format_spec) .          New in version 2.6.      "]},
{"name": ["frozenset"], "description": ["Return a new  frozenset  object, optionally with elements taken from   iterable .   frozenset  is a built-in class.  See  frozenset  and   Set Types -- set, frozenset  for documentation about this class.    For other containers see the built-in  set ,  list ,   tuple , and  dict  classes, as well as the  collections   module.       New in version 2.4.      "]},
{"name": ["getattr"], "description": ["Return the value of the named attribute of  object .   name  must be a string.  If the string is the name of one of the object's attributes, the result is the  value of that attribute.  For example,  getattr(x,   'foobar')  is equivalent to   x.foobar .  If the named attribute does not exist,  default  is returned if  provided, otherwise  AttributeError  is raised.   "]},
{"name": ["globals"], "description": ["Return a dictionary representing the current global symbol table. This is always  the dictionary of the current module (inside a function or method, this is the  module where it is defined, not the module from which it is called).   "]},
{"name": ["hasattr"], "description": ["The arguments are an object and a string.  The result is  True  if the string  is the name of one of the object's attributes,  False  if not. (This is  implemented by calling  getattr(object,   name)  and seeing whether it raises an  exception or not.)   "]},
{"name": ["hash"], "description": ["Return the hash value of the object (if it has one).  Hash values are integers.  They are used to quickly compare dictionary keys during a dictionary lookup.  Numeric values that compare equal have the same hash value (even if they are of  different types, as is the case for 1 and 1.0).   "]},
{"name": ["help"], "description": ["Invoke the built-in help system.  (This function is intended for interactive  use.)  If no argument is given, the interactive help system starts on the  interpreter console.  If the argument is a string, then the string is looked up  as the name of a module, function, class, method, keyword, or documentation  topic, and a help page is printed on the console.  If the argument is any other  kind of object, a help page on the object is generated.    This function is added to the built-in namespace by the  site  module.       New in version 2.2.      "]},
{"name": ["hex"], "description": ["Convert an integer number (of any size) to a lowercase hexadecimal string  prefixed with \"0x\", for example:    >>>  hex ( 255 )    '0xff'    >>>  hex ( - 42 )    '-0x2a'    >>>  hex ( 1L )    '0x1L'          If x is not a Python  int  or  long  object, it has to  define an __index__() method that returns an integer.    See also  int()  for converting a hexadecimal string to an  integer using a base of 16.       Note    To obtain a hexadecimal string representation for a float, use the   float.hex()  method.          Changed in version 2.4:  Formerly only returned an unsigned literal.      "]},
{"name": ["id"], "description": ["Return the \"identity\" of an object.  This is an integer (or long integer) which  is guaranteed to be unique and constant for this object during its lifetime.  Two objects with non-overlapping lifetimes may have the same  id()   value.       CPython implementation detail:  This is the address of the object in memory.      "]},
{"name": ["input"], "description": ["Equivalent to  eval(raw_input(prompt)) .    This function does not catch user errors. If the input is not syntactically  valid, a  SyntaxError  will be raised. Other exceptions may be raised if  there is an error during evaluation.    If the  readline  module was loaded, then  input()  will use it to  provide elaborate line editing and history features.    Consider using the  raw_input()  function for general input from users.   "]},
{"name": ["int"], "description": ["Return an integer object constructed from a number or string  x , or return  0  if no  arguments are given.  If  x  is a number, it can be a plain integer, a long  integer, or a floating point number.  If  x  is floating point, the conversion  truncates towards zero.  If the argument is outside the integer range, the  function returns a long object instead.    If  x  is not a number or if  base  is given, then  x  must be a string or  Unicode object representing an  integer literal  in radix   base .  Optionally, the literal can be  preceded by  +  or  -  (with no space in between) and surrounded by  whitespace.  A base-n literal consists of the digits 0 to n-1, with  a   to  z  (or  A  to  Z ) having  values 10 to 35.  The default  base  is 10. The allowed values are 0 and 2-36.  Base-2, -8, and -16 literals can be optionally prefixed with  0b / 0B ,   0o / 0O / 0 , or  0x / 0X , as with integer literals in code.  Base 0 means to interpret the string exactly as an integer literal, so that  the actual base is 2, 8, 10, or 16.    The integer type is described in  Numeric Types -- int, float, long, complex .   "]},
{"name": ["isinstance"], "description": ["Return true if the  object  argument is an instance of the  classinfo  argument,  or of a (direct, indirect or  virtual ) subclass  thereof.  Also return true if  classinfo   is a type object (new-style class) and  object  is an object of that type or of  a (direct, indirect or  virtual ) subclass  thereof.  If  object  is not a class instance or  an object of the given type, the function always returns false.  If  classinfo   is neither a class object nor a type object, it may be a tuple of class or type  objects, or may recursively contain other such tuples (other sequence types are  not accepted).  If  classinfo  is not a class, type, or tuple of classes, types,  and such tuples, a  TypeError  exception is raised.       Changed in version 2.2:  Support for a tuple of type information was added.      "]},
{"name": ["issubclass"], "description": ["Return true if  class  is a subclass (direct, indirect or  virtual ) of  classinfo .  A  class is considered a subclass of itself.  classinfo  may be a tuple of class  objects, in which case every entry in  classinfo  will be checked. In any other  case, a  TypeError  exception is raised.       Changed in version 2.3:  Support for a tuple of type information was added.      "]},
{"name": ["iter"], "description": ["Return an  iterator  object.  The first argument is interpreted very differently  depending on the presence of the second argument. Without a second argument,  o   must be a collection object which supports the iteration protocol (the   __iter__()  method), or it must support the sequence protocol (the   __getitem__()  method with integer arguments starting at  0 ).  If it  does not support either of those protocols,  TypeError  is raised. If the  second argument,  sentinel , is given, then  o  must be a callable object.  The  iterator created in this case will call  o  with no arguments for each call to  its  next()  method; if the value returned is equal to  sentinel ,   StopIteration  will be raised, otherwise the value will be returned.    One useful application of the second form of  iter()  is to read lines of  a file until a certain line is reached.  The following example reads a file  until the  readline()  method returns an empty string:    with   open ( 'mydata.txt' )   as   fp :        for   line   in   iter ( fp . readline ,   '' ):            process_line ( line )             New in version 2.2.      "]},
{"name": ["len"], "description": ["Return the length (the number of items) of an object.  The argument may be a  sequence (such as a string, bytes, tuple, list, or range) or a collection  (such as a dictionary, set, or frozen set).   "]},
{"name": ["list"], "description": ["Return a list whose items are the same and in the same order as  iterable's  items.   iterable  may be either a sequence, a container that supports  iteration, or an iterator object.  If  iterable  is already a list, a copy is  made and returned, similar to  iterable[:] .  For instance,  list('abc')   returns  ['a',   'b',   'c']  and  list(   (1,   2,   3)   )  returns  [1,   2,   3] .  If  no argument is given, returns a new empty list,  [] .    list  is a mutable sequence type, as documented in   Sequence Types -- str, unicode, list, tuple, bytearray, buffer, xrange . For other containers see the built in  dict ,   set , and  tuple  classes, and the  collections  module.   "]},
{"name": ["locals"], "description": ["Update and return a dictionary representing the current local symbol table.  Free variables are returned by  locals()  when it is called in function  blocks, but not in class blocks.       Note    The contents of this dictionary should not be modified; changes may not  affect the values of local and free variables used by the interpreter.      "]},
{"name": ["long"], "description": ["Return a long integer object constructed from a string or number  x .  If the argument is a string, it  must contain a possibly signed number of arbitrary size, possibly embedded in  whitespace. The  base  argument is interpreted in the same way as for   int() , and may only be given when  x  is a string. Otherwise, the argument  may be a plain or long integer or a floating point number, and a long integer  with the same value is returned.    Conversion of floating point numbers to  integers truncates (towards zero).  If no arguments are given, returns  0L .    The long type is described in  Numeric Types -- int, float, long, complex .   "]},
{"name": ["map"], "description": ["Apply  function  to every item of  iterable  and return a list of the results.  If additional  iterable  arguments are passed,  function  must take that many  arguments and is applied to the items from all iterables in parallel.  If one  iterable is shorter than another it is assumed to be extended with  None   items.  If  function  is  None , the identity function is assumed; if there  are multiple arguments,  map()  returns a list consisting of tuples  containing the corresponding items from all iterables (a kind of transpose  operation).  The  iterable  arguments may be a sequence  or any iterable object;  the result is always a list.   "]},
{"name": ["max"], "description": ["Return the largest item in an iterable or the largest of two or more  arguments.    If one positional argument is provided,  iterable  must be a non-empty  iterable (such as a non-empty string, tuple or list).  The largest item  in the iterable is returned.  If two or more positional arguments are  provided, the largest of the positional arguments is returned.    The optional  key  argument specifies a one-argument ordering function like that  used for  list.sort() .  The  key  argument, if supplied, must be in keyword  form (for example,  max(a,b,c,key=func) ).       Changed in version 2.5:  Added support for the optional  key  argument.      "]},
{"name": ["memoryview"], "description": ["Return a \"memory view\" object created from the given argument.  See   memoryview type  for more information.   "]},
{"name": ["min"], "description": ["Return the smallest item in an iterable or the smallest of two or more  arguments.    If one positional argument is provided,  iterable  must be a non-empty  iterable (such as a non-empty string, tuple or list).  The smallest item  in the iterable is returned.  If two or more positional arguments are  provided, the smallest of the positional arguments is returned.    The optional  key  argument specifies a one-argument ordering function like that  used for  list.sort() .  The  key  argument, if supplied, must be in keyword  form (for example,  min(a,b,c,key=func) ).       Changed in version 2.5:  Added support for the optional  key  argument.      "]},
{"name": ["next"], "description": ["Retrieve the next item from the  iterator  by calling its   next()  method.  If  default  is given, it is returned if the  iterator is exhausted, otherwise  StopIteration  is raised.       New in version 2.6.      "]},
{"name": ["object"], "description": ["Return a new featureless object.   object  is a base for all new style  classes.  It has the methods that are common to all instances of new style  classes.       New in version 2.2.          Changed in version 2.3:  This function does not accept any arguments. Formerly, it accepted arguments but  ignored them.      "]},
{"name": ["oct"], "description": ["Convert an integer number (of any size) to an octal string.  The result is a  valid Python expression.       Changed in version 2.4:  Formerly only returned an unsigned literal.      "]},
{"name": ["open"], "description": ["Open a file, returning an object of the  file  type described in  section  File Objects .  If the file cannot be opened,   IOError  is raised.  When opening a file, it's preferable to use   open()  instead of invoking the  file  constructor directly.    The first two arguments are the same as for  stdio's  fopen() :   name  is the file name to be opened, and  mode  is a string indicating how  the file is to be opened.    The most commonly-used values of  mode  are  'r'  for reading,  'w'  for  writing (truncating the file if it already exists), and  'a'  for appending  (which on  some  Unix systems means that  all  writes append to the end of the  file regardless of the current seek position).  If  mode  is omitted, it  defaults to  'r' .  The default is to use text mode, which may convert   '\  '  characters to a platform-specific representation on writing and back  on reading.  Thus, when opening a binary file, you should append  'b'  to  the  mode  value to open the file in binary mode, which will improve  portability.  (Appending  'b'  is useful even on systems that don't treat  binary and text files differently, where it serves as documentation.)  See below  for more possible values of  mode .    The optional  buffering  argument specifies the file's desired buffer size: 0  means unbuffered, 1 means line buffered, any other positive value means use a  buffer of (approximately) that size (in bytes).  A negative  buffering  means  to use the system default, which is usually line buffered for tty devices and  fully buffered for other files.  If omitted, the system default is used.  [2]    Modes  'r+' ,  'w+'  and  'a+'  open the file for updating (reading and writing);  note that  'w+'  truncates the file.  Append  'b'  to the mode to open the file in  binary mode, on systems that differentiate between binary and text files; on  systems that don't have this distinction, adding the  'b'  has no effect.    In addition to the standard  fopen()  values  mode  may be  'U'  or   'rU' .  Python is usually built with  universal newlines  support;  supplying  'U'  opens the file as a text file, but lines may be terminated  by any of the following: the Unix end-of-line convention  '\  ' ,  the  Macintosh convention  '\\r' , or the Windows convention  '\\r\  ' . All of  these external representations are seen as  '\  '  by the Python program.  If Python is built without universal newlines support a  mode  with  'U'   is the same as normal text mode.  Note that file objects so opened also have  an attribute called  newlines  which has a value of  None  (if no  newlines have yet been seen),  '\  ' ,  '\\r' ,  '\\r\  ' , or a tuple  containing all the newline types seen.    Python enforces that the mode, after stripping  'U' , begins with  'r' ,   'w'  or  'a' .    Python provides many file handling modules including   fileinput ,  os ,  os.path ,  tempfile , and   shutil .       Changed in version 2.5:  Restriction on first letter of mode string introduced.      "]},
{"name": ["ord"], "description": ["Given a string of length one, return an integer representing the Unicode code  point of the character when the argument is a unicode object, or the value of  the byte when the argument is an 8-bit string. For example,  ord('a')  returns  the integer  97 ,  ord(niccage)  returns  8224 .  This is the inverse of   chr()  for 8-bit strings and of  unichr()  for unicode objects.  If a  unicode argument is given and Python was built with UCS2 Unicode, then the  character's code point must be in the range [0..65535] inclusive; otherwise the  string length is two, and a  TypeError  will be raised.   "]},
{"name": ["pow"], "description": ["Return  x  to the power  y ; if  z  is present, return  x  to the power  y ,  modulo  z  (computed more efficiently than  pow(x,   y)   %   z ). The two-argument  form  pow(x,   y)  is equivalent to using the power operator:  x**y .    The arguments must have numeric types.  With mixed operand types, the coercion  rules for binary arithmetic operators apply.  For int and long int operands, the  result has the same type as the operands (after coercion) unless the second  argument is negative; in that case, all arguments are converted to float and a  float result is delivered.  For example,  10**2  returns  100 , but   10**-2  returns  0.01 .  (This last feature was added in Python 2.2.  In  Python 2.1 and before, if both arguments were of integer types and the second  argument was negative, an exception was raised.) If the second argument is  negative, the third argument must be omitted. If  z  is present,  x  and  y   must be of integer types, and  y  must be non-negative.  (This restriction was  added in Python 2.2.  In Python 2.1 and before, floating 3-argument  pow()   returned platform-dependent results depending on floating-point rounding  accidents.)   "]},
{"name": ["print"], "description": ["Print  objects  to the stream  file , separated by  sep  and followed by   end .   sep ,  end  and  file , if present, must be given as keyword  arguments.    All non-keyword arguments are converted to strings like  str()  does and  written to the stream, separated by  sep  and followed by  end .  Both  sep   and  end  must be strings; they can also be  None , which means to use the  default values.  If no  objects  are given,  print()  will just write   end .    The  file  argument must be an object with a  write(string)  method; if it  is not present or  None ,  sys.stdout  will be used.  Output buffering  is determined by  file .  Use  file.flush()  to ensure, for instance,  immediate appearance on a screen.       Note    This function is not normally available as a built-in since the name   print  is recognized as the  print  statement.  To disable the  statement and use the  print()  function, use this future statement at  the top of your module:    from   __future__   import   print_function                New in version 2.6.      "]},
{"name": ["property"], "description": ["Return a property attribute for  new-style class es (classes that  derive from  object ).    fget  is a function for getting an attribute value.   fset  is a function  for setting an attribute value.  fdel  is a function for deleting an attribute  value.  And  doc  creates a docstring for the attribute.    A typical use is to define a managed attribute  x :    class   C ( object ):        def   __init__ ( self ):            self . _x   =   None          def   getx ( self ):            return   self . _x          def   setx ( self ,   value ):            self . _x   =   value          def   delx ( self ):            del   self . _x          x   =   property ( getx ,   setx ,   delx ,   \"I'm the 'x' property.\" )          If  c  is an instance of  C ,  c.x  will invoke the getter,   c.x   =   value  will invoke the setter and  del   c.x  the deleter.    If given,  doc  will be the docstring of the property attribute. Otherwise, the  property will copy  fget's docstring (if it exists).  This makes it possible to  create read-only properties easily using  property()  as a  decorator :    class   Parrot ( object ):        def   __init__ ( self ):            self . _voltage   =   100000          @property        def   voltage ( self ):            \"\"\"Get the current voltage.\"\"\"            return   self . _voltage          The  @property  decorator turns the  voltage()  method into a \"getter\"  for a read-only attribute with the same name, and it sets the docstring for   voltage  to \"Get the current voltage.\"    A property object has  getter ,  setter ,  and  deleter  methods usable as decorators that create a  copy of the property with the corresponding accessor function set to the  decorated function.  This is best explained with an example:    class   C ( object ):        def   __init__ ( self ):            self . _x   =   None          @property        def   x ( self ):            \"\"\"I'm the 'x' property.\"\"\"            return   self . _x          @x.setter        def   x ( self ,   value ):            self . _x   =   value          @x.deleter        def   x ( self ):            del   self . _x          This code is exactly equivalent to the first example.  Be sure to give the  additional functions the same name as the original property ( x  in this  case.)    The returned property object also has the attributes  fget ,  fset , and   fdel  corresponding to the constructor arguments.       New in version 2.2.          Changed in version 2.5:  Use  fget's docstring if no  doc  given.          Changed in version 2.6:  The  getter ,  setter , and  deleter  attributes were added.      "]},
{"name": ["range"], "description": ["This is a versatile function to create lists containing arithmetic progressions.  It is most often used in  for  loops.  The arguments must be plain  integers.  If the  step  argument is omitted, it defaults to  1 .  If the   start  argument is omitted, it defaults to  0 .  The full form returns a list  of plain integers  [start,   start   +   step,   start   +   2   *   step,   ...] .  If  step   is positive, the last element is the largest  start   +   i   *   step  less than   stop ; if  step  is negative, the last element is the smallest  start   +   i   *    step  greater than  stop .   step  must not be zero (or else  ValueError   is raised).  Example:    >>>  range ( 10 )    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]    >>>  range ( 1 ,   11 )    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]    >>>  range ( 0 ,   30 ,   5 )    [0, 5, 10, 15, 20, 25]    >>>  range ( 0 ,   10 ,   3 )    [0, 3, 6, 9]    >>>  range ( 0 ,   - 10 ,   - 1 )    [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]    >>>  range ( 0 )    []    >>>  range ( 1 ,   0 )    []         "]},
{"name": ["raw_input"], "description": ["If the  prompt  argument is present, it is written to standard output without a  trailing newline.  The function then reads a line from input, converts it to a  string (stripping a trailing newline), and returns that. When EOF is read,   EOFError  is raised. Example:    >>>  s   =   raw_input ( '--> ' )    --> Monty Python's Flying Circus    >>>  s    \"Monty Python's Flying Circus\"          If the  readline  module was loaded, then  raw_input()  will use it to  provide elaborate line editing and history features.   "]},
{"name": ["reduce"], "description": ["Apply  function  of two arguments cumulatively to the items of  iterable , from  left to right, so as to reduce the iterable to a single value.  For example,   reduce(lambda   x,   y:   x+y,   [1,   2,   3,   4,   5])  calculates  ((((1+2)+3)+4)+5) .  The left argument,  x , is the accumulated value and the right argument,  y , is  the update value from the  iterable .  If the optional  initializer  is present,  it is placed before the items of the iterable in the calculation, and serves as  a default when the iterable is empty.  If  initializer  is not given and   iterable  contains only one item, the first item is returned.  Roughly equivalent to:    def   reduce ( function ,   iterable ,   initializer = None ):        it   =   iter ( iterable )        if   initializer   is   None :            try :                initializer   =   next ( it )            except   StopIteration :                raise   TypeError ( 'reduce() of empty sequence with no initial value' )        accum_value   =   initializer        for   x   in   it :            accum_value   =   function ( accum_value ,   x )        return   accum_value         "]},
{"name": ["reload"], "description": ["Reload a previously imported  module .  The argument must be a module object, so  it must have been successfully imported before.  This is useful if you have  edited the module source file using an external editor and want to try out the  new version without leaving the Python interpreter.  The return value is the  module object (the same as the  module  argument).    When  reload(module)  is executed:    Python modules' code is recompiled and the module-level code reexecuted,  defining a new set of objects which are bound to names in the module's  dictionary.  The  init  function of extension modules is not called a second  time.    As with all other objects in Python the old objects are only reclaimed after  their reference counts drop to zero.    The names in the module namespace are updated to point to any new or changed  objects.    Other references to the old objects (such as names external to the module) are  not rebound to refer to the new objects and must be updated in each namespace  where they occur if that is desired.    There are a number of other caveats:    If a module is syntactically correct but its initialization fails, the first   import  statement for it does not bind its name locally, but does  store a (partially initialized) module object in  sys.modules .  To reload the  module you must first  import  it again (this will bind the name to the  partially initialized module object) before you can  reload()  it.    When a module is reloaded, its dictionary (containing the module's global  variables) is retained.  Redefinitions of names will override the old  definitions, so this is generally not a problem.  If the new version of a module  does not define a name that was defined by the old version, the old definition  remains.  This feature can be used to the module's advantage if it maintains a  global table or cache of objects -- with a  try  statement it can test  for the table's presence and skip its initialization if desired:    try :        cache    except   NameError :        cache   =   {}          It is legal though generally not very useful to reload built-in or dynamically  loaded modules, except for  sys ,  __main__  and  __builtin__ .  In many cases, however, extension modules are not designed to be initialized  more than once, and may fail in arbitrary ways when reloaded.    If a module imports objects from another module using  from  ...   import  ..., calling  reload()  for the other module does not  redefine the objects imported from it -- one way around this is to re-execute  the  from  statement, another is to use  import  and qualified  names ( module .*name*) instead.    If a module instantiates instances of a class, reloading the module that defines  the class does not affect the method definitions of the instances -- they  continue to use the old class definition.  The same is true for derived classes.   "]},
{"name": ["repr"], "description": ["Return a string containing a printable representation of an object.  This is  the same value yielded by conversions (reverse quotes).  It is sometimes  useful to be able to access this operation as an ordinary function.  For many  types, this function makes an attempt to return a string that would yield an  object with the same value when passed to  eval() , otherwise the  representation is a string enclosed in angle brackets that contains the name  of the type of the object together with additional information often  including the name and address of the object.  A class can control what this  function returns for its instances by defining a  __repr__()  method.   "]},
{"name": ["reversed"], "description": ["Return a reverse  iterator .   seq  must be an object which has  a  __reversed__()  method or supports the sequence protocol (the   __len__()  method and the  __getitem__()  method with integer  arguments starting at  0 ).       New in version 2.4.          Changed in version 2.6:  Added the possibility to write a custom  __reversed__()  method.      "]},
{"name": ["round"], "description": ["Return the floating point value  number  rounded to  ndigits  digits after  the decimal point.  If  ndigits  is omitted, it defaults to zero. The result  is a floating point number.  Values are rounded to the closest multiple of  10 to the power minus  ndigits ; if two multiples are equally close,  rounding is done away from 0 (so, for example,  round(0.5)  is  1.0  and   round(-0.5)  is  -1.0 ).       Note    The behavior of  round()  for floats can be surprising: for example,   round(2.675,   2)  gives  2.67  instead of the expected  2.68 .  This is not a bug: it's a result of the fact that most decimal fractions  can't be represented exactly as a float.  See  Floating Point Arithmetic:  Issues and Limitations  for  more information.      "]},
{"name": ["set"], "description": ["Return a new  set  object, optionally with elements taken from   iterable .   set  is a built-in class.  See  set  and   Set Types -- set, frozenset  for documentation about this class.    For other containers see the built-in  frozenset ,  list ,   tuple , and  dict  classes, as well as the  collections   module.       New in version 2.4.      "]},
{"name": ["setattr"], "description": ["This is the counterpart of  getattr() .  The arguments are an object, a  string and an arbitrary value.  The string may name an existing attribute or a  new attribute.  The function assigns the value to the attribute, provided the  object allows it.  For example,  setattr(x,   'foobar',   123)  is equivalent to   x.foobar   =   123 .   "]},
{"name": ["slice "], "description": ["Return a  slice  object representing the set of indices specified by   range(start,   stop,   step) .  The  start  and  step  arguments default to   None .  Slice objects have read-only data attributes  start ,   stop  and  step  which merely return the argument  values (or their default).  They have no other explicit functionality;  however they are used by Numerical Python and other third party extensions.  Slice objects are also generated when extended indexing syntax is used.  For  example:  a[start:stop:step]  or  a[start:stop,   i] .  See   itertools.islice()  for an alternate version that returns an iterator.   "]},
{"name": ["sorted"], "description": ["Return a new sorted list from the items in  iterable .    The optional arguments  cmp ,  key , and  reverse  have the same meaning as  those for the  list.sort()  method (described in section   Mutable Sequence Types ).    cmp  specifies a custom comparison function of two arguments (iterable  elements) which should return a negative, zero or positive number depending on  whether the first argument is considered smaller than, equal to, or larger than  the second argument:  cmp=lambda   x,y:   cmp(x.lower(),   y.lower()) .  The default  value is  None .    key  specifies a function of one argument that is used to extract a comparison  key from each list element:  key=str.lower .  The default value is  None   (compare the elements directly).    reverse  is a boolean value.  If set to  True , then the list elements are  sorted as if each comparison were reversed.    In general, the  key  and  reverse  conversion processes are much faster  than specifying an equivalent  cmp  function.  This is because  cmp  is  called multiple times for each list element while  key  and  reverse  touch  each element only once.  Use  functools.cmp_to_key()  to convert an  old-style  cmp  function to a  key  function.    The built-in  sorted()  function is guaranteed to be stable. A sort is  stable if it guarantees not to change the relative order of elements that  compare equal -- this is helpful for sorting in multiple passes (for  example, sort by department, then by salary grade).    For sorting examples and a brief sorting tutorial, see  Sorting HOW TO .       New in version 2.4.      "]},
{"name": ["staticmethod"], "description": ["Return a static method for  function .    A static method does not receive an implicit first argument. To declare a static  method, use this idiom:    class   C ( object ):        @staticmethod        def   f ( arg1 ,   arg2 ,   ... ):            ...          The  @staticmethod  form is a function  decorator  - see the  description of function definitions in  Function definitions  for details.    It can be called either on the class (such as  C.f() ) or on an instance (such  as  C().f() ).  The instance is ignored except for its class.    Static methods in Python are similar to those found in Java or C++. Also see   classmethod()  for a variant that is useful for creating alternate  class constructors.    For more information on static methods, consult the documentation on the  standard type hierarchy in  The standard type hierarchy .       New in version 2.2.          Changed in version 2.4:  Function decorator syntax added.      "]},
{"name": ["str"], "description": ["Return a string containing a nicely printable representation of an object.  For  strings, this returns the string itself.  The difference with  repr(object)   is that  str(object)  does not always attempt to return a string that is  acceptable to  eval() ; its goal is to return a printable string.  If no  argument is given, returns the empty string,  '' .    For more information on strings see  Sequence Types -- str, unicode, list, tuple, bytearray, buffer, xrange  which describes sequence  functionality (strings are sequences), and also the string-specific methods  described in the  String Methods  section. To output formatted strings  use template strings or the  %  operator described in the   String Formatting Operations  section. In addition see the  String Services   section. See also  unicode() .   "]},
{"name": ["sum"], "description": ["Sums  start  and the items of an  iterable  from left to right and returns the  total.   start  defaults to  0 . The  iterable's items are normally numbers,  and the start value is not allowed to be a string.    For some use cases, there are good alternatives to  sum() .  The preferred, fast way to concatenate a sequence of strings is by calling   ''.join(sequence) .  To add floating point values with extended precision,  see  math.fsum() .  To concatenate a series of iterables, consider using   itertools.chain() .       New in version 2.3.      "]},
{"name": ["super"], "description": ["Return a proxy object that delegates method calls to a parent or sibling  class of  type .  This is useful for accessing inherited methods that have  been overridden in a class. The search order is same as that used by   getattr()  except that the  type  itself is skipped.    The  __mro__  attribute of the  type  lists the method  resolution search order used by both  getattr()  and  super() .  The  attribute is dynamic and can change whenever the inheritance hierarchy is  updated.    If the second argument is omitted, the super object returned is unbound.  If  the second argument is an object,  isinstance(obj,   type)  must be true.  If  the second argument is a type,  issubclass(type2,   type)  must be true (this  is useful for classmethods).       Note    super()  only works for  new-style class es.       There are two typical use cases for  super .  In a class hierarchy with  single inheritance,  super  can be used to refer to parent classes without  naming them explicitly, thus making the code more maintainable.  This use  closely parallels the use of  super  in other programming languages.    The second use case is to support cooperative multiple inheritance in a  dynamic execution environment.  This use case is unique to Python and is  not found in statically compiled languages or languages that only support  single inheritance.  This makes it possible to implement \"diamond diagrams\"  where multiple base classes implement the same method.  Good design dictates  that this method have the same calling signature in every case (because the  order of calls is determined at runtime, because that order adapts  to changes in the class hierarchy, and because that order can include  sibling classes that are unknown prior to runtime).    For both use cases, a typical superclass call looks like this:    class   C ( B ):        def   method ( self ,   arg ):            super ( C ,   self ) . method ( arg )          Note that  super()  is implemented as part of the binding process for  explicit dotted attribute lookups such as  super().__getitem__(name) .  It does so by implementing its own  __getattribute__()  method for searching  classes in a predictable order that supports cooperative multiple inheritance.  Accordingly,  super()  is undefined for implicit lookups using statements or  operators such as  super()[name] .    Also note that  super()  is not limited to use inside methods.  The two  argument form specifies the arguments exactly and makes the appropriate  references.    For practical suggestions on how to design cooperative classes using   super() , see  guide to using super() .       New in version 2.2.      "]},
{"name": ["tuple"], "description": ["Return a tuple whose items are the same and in the same order as  iterable's  items.   iterable  may be a sequence, a container that supports iteration, or an  iterator object. If  iterable  is already a tuple, it is returned unchanged.  For instance,  tuple('abc')  returns  ('a',   'b',   'c')  and  tuple([1,   2,    3])  returns  (1,   2,   3) .  If no argument is given, returns a new empty  tuple,  () .    tuple  is an immutable sequence type, as documented in   Sequence Types -- str, unicode, list, tuple, bytearray, buffer, xrange . For other containers see the built in  dict ,   list , and  set  classes, and the  collections  module.   "]},
{"name": ["type type"], "description": ["With one argument, return the type of an  object .  The return value is a  type object.  The  isinstance()  built-in function is recommended for  testing the type of an object.    With three arguments, return a new type object.  This is essentially a  dynamic form of the  class  statement. The  name  string is the  class name and becomes the  __name__  attribute; the  bases  tuple  itemizes the base classes and becomes the  __bases__  attribute;  and the  dict  dictionary is the namespace containing definitions for class  body and becomes the  __dict__   attribute.  For example, the  following two statements create identical  type  objects:    >>>  class   X ( object ):    ...       a   =   1    ...    >>>  X   =   type ( 'X' ,   ( object ,),   dict ( a = 1 ))             New in version 2.2.      "]},
{"name": ["unichr"], "description": ["Return the Unicode string of one character whose Unicode code is the integer   i .  For example,  unichr(97)  returns the string  u'a' .  This is the  inverse of  ord()  for Unicode strings.  The valid range for the argument  depends how Python was configured - it may be either UCS2 [0..0xFFFF] or UCS4  [0..0x10FFFF].  ValueError  is raised otherwise. For ASCII and 8-bit  strings see  chr() .       New in version 2.0.      "]},
{"name": ["unicode"], "description": ["Return the Unicode string version of  object  using one of the following modes:    If  encoding  and/or  errors  are given,  unicode()  will decode the object  which can either be an 8-bit string or a character buffer using the codec for   encoding . The  encoding  parameter is a string giving the name of an encoding;  if the encoding is not known,  LookupError  is raised. Error handling is  done according to  errors ; this specifies the treatment of characters which are  invalid in the input encoding.  If  errors  is  'strict'  (the default), a   ValueError  is raised on errors, while a value of  'ignore'  causes  errors to be silently ignored, and a value of  'replace'  causes the official  Unicode replacement character,  U+FFFD , to be used to replace input  characters which cannot be decoded.  See also the  codecs  module.    If no optional parameters are given,  unicode()  will mimic the behaviour of   str()  except that it returns Unicode strings instead of 8-bit strings. More  precisely, if  object  is a Unicode string or subclass it will return that  Unicode string without any additional decoding applied.    For objects which provide a  __unicode__()  method, it will call this method  without arguments to create a Unicode string. For all other objects, the 8-bit  string version or representation is requested and then converted to a Unicode  string using the codec for the default encoding in  'strict'  mode.    For more information on Unicode strings see  Sequence Types -- str, unicode, list, tuple, bytearray, buffer, xrange  which describes  sequence functionality (Unicode strings are sequences), and also the  string-specific methods described in the  String Methods  section. To  output formatted strings use template strings or the  %  operator described  in the  String Formatting Operations  section. In addition see the   String Services  section. See also  str() .       New in version 2.0.          Changed in version 2.2:  Support for  __unicode__()  added.      "]},
{"name": ["vars"], "description": ["Return the  __dict__  attribute for a module, class, instance,  or any other object with a  __dict__  attribute.    Objects such as modules and instances have an updateable  __dict__   attribute; however, other objects may have write restrictions on their   __dict__  attributes (for example, new-style classes use a  dictproxy to prevent direct dictionary updates).    Without an argument,  vars()  acts like  locals() .  Note, the  locals dictionary is only useful for reads since updates to the locals  dictionary are ignored.   "]},
{"name": ["xrange"], "description": ["This function is very similar to  range() , but returns an  xrange  object   instead of a list.  This is an opaque sequence type which yields the same values  as the corresponding list, without actually storing them all simultaneously.  The advantage of  xrange()  over  range()  is minimal (since   xrange()  still has to create the values when asked for them) except when a  very large range is used on a memory-starved machine or when all of the range's  elements are never used (such as when the loop is usually terminated with   break ).  For more information on xrange objects, see   XRange Type  and  Sequence Types -- str, unicode, list, tuple, bytearray, buffer, xrange .       CPython implementation detail:   xrange()  is intended to be simple and fast.  Implementations may  impose restrictions to achieve this.  The C implementation of Python  restricts all arguments to native C longs (\"short\" Python integers), and  also requires that the number of elements fit in a native C long.  If a  larger range is needed, an alternate version can be crafted using the   itertools  module:  islice(count(start,   step),    (stop-start+step-1+2*(step<0))//step) .      "]},
{"name": ["zip"], "description": ["This function returns a list of tuples, where the  i -th tuple contains the   i -th element from each of the argument sequences or iterables. The returned  list is truncated in length to the length of the shortest argument sequence.  When there are multiple arguments which are all of the same length,  zip()   is similar to  map()  with an initial argument of  None . With a single  sequence argument, it returns a list of 1-tuples. With no arguments, it returns  an empty list.    The left-to-right evaluation order of the iterables is guaranteed. This  makes possible an idiom for clustering a data series into n-length groups  using  zip(*[iter(s)]*n) .    zip()  in conjunction with the  *  operator can be used to unzip a  list:    >>>  x   =   [ 1 ,   2 ,   3 ]    >>>  y   =   [ 4 ,   5 ,   6 ]    >>>  zipped   =   zip ( x ,   y )    >>>  zipped    [(1, 4), (2, 5), (3, 6)]    >>>  x2 ,   y2   =   zip ( * zipped )    >>>  x   ==   list ( x2 )   and   y   ==   list ( y2 )    True             New in version 2.0.          Changed in version 2.4:  Formerly,  zip()  required at least one argument and  zip()  raised a   TypeError  instead of returning an empty list.      "]},
{"name": ["__import__"], "description": ["   Note    This is an advanced function that is not needed in everyday Python  programming, unlike  importlib.import_module() .       This function is invoked by the  import  statement.  It can be  replaced (by importing the  __builtin__  module and assigning to   __builtin__.__import__ ) in order to change semantics of the   import  statement, but nowadays it is usually simpler to use import  hooks (see  PEP 302 ).  Direct use of  __import__()  is rare, except in  cases where you want to import a module whose name is only known at runtime.    The function imports the module  name , potentially using the given  globals   and  locals  to determine how to interpret the name in a package context.  The  fromlist  gives the names of objects or submodules that should be  imported from the module given by  name .  The standard implementation does  not use its  locals  argument at all, and uses its  globals  only to  determine the package context of the  import  statement.    level  specifies whether to use absolute or relative imports.  The default  is  -1  which indicates both absolute and relative imports will be  attempted.   0  means only perform absolute imports.  Positive values for   level  indicate the number of parent directories to search relative to the  directory of the module calling  __import__() .    When the  name  variable is of the form  package.module , normally, the  top-level package (the name up till the first dot) is returned,  not  the  module named by  name .  However, when a non-empty  fromlist  argument is  given, the module named by  name  is returned.    For example, the statement  import   spam  results in bytecode resembling the  following code:    spam   =   __import__ ( 'spam' ,   globals (),   locals (),   [],   - 1 )          The statement  import   spam.ham  results in this call:    spam   =   __import__ ( 'spam.ham' ,   globals (),   locals (),   [],   - 1 )          Note how  __import__()  returns the toplevel module here because this is  the object that is bound to a name by the  import  statement.    On the other hand, the statement  from   spam.ham   import   eggs,   sausage   as    saus  results in    _temp   =   __import__ ( 'spam.ham' ,   globals (),   locals (),   [ 'eggs' ,   'sausage' ],   - 1 )    eggs   =   _temp . eggs    saus   =   _temp . sausage          Here, the  spam.ham  module is returned from  __import__() .  From this  object, the names to import are retrieved and assigned to their respective  names.    If you simply want to import a module (potentially within a package) by name,  use  importlib.import_module() .       Changed in version 2.5:  The level parameter was added.          Changed in version 2.5:  Keyword support for parameters was added.      "]},
{"name": ["apply"], "description": ["The  function  argument must be a callable object (a user-defined or built-in  function or method, or a class object) and the  args  argument must be a  sequence.  The  function  is called with  args  as the argument list; the number  of arguments is the length of the tuple. If the optional  keywords  argument is  present, it must be a dictionary whose keys are strings.  It specifies keyword  arguments to be added to the end of the argument list. Calling  apply()  is  different from just calling  function(args) , since in that case there is  always exactly one argument.  The use of  apply()  is equivalent to   function(*args,   **keywords) .       Deprecated since version 2.3:  Use  function(*args,   **keywords)  instead of   apply(function,   args,   keywords)  (see  Unpacking Argument Lists ).      "]},
{"name": ["buffer"], "description": ["The  object  argument must be an object that supports the buffer call interface  (such as strings, arrays, and buffers).  A new buffer object will be created  which references the  object  argument. The buffer object will be a slice from  the beginning of  object  (or from the specified  offset ). The slice will  extend to the end of  object  (or will have a length given by the  size   argument).   "]},
{"name": ["coerce"], "description": ["Return a tuple consisting of the two numeric arguments converted to a common  type, using the same rules as used by arithmetic operations. If coercion is not  possible, raise  TypeError .   "]},
{"name": ["intern"], "description": ["Enter  string  in the table of \"interned\" strings and return the interned string  - which is  string  itself or a copy. Interning strings is useful to gain a  little performance on dictionary lookup - if the keys in a dictionary are  interned, and the lookup key is interned, the key comparisons (after hashing)  can be done by a pointer compare instead of a string compare.  Normally, the  names used in Python programs are automatically interned, and the dictionaries  used to hold module, class or instance attributes have interned keys.       Changed in version 2.3:  Interned strings are not immortal (like they used to be in Python 2.2 and  before); you must keep a reference to the return value of  intern()  around  to benefit from it.      "]},
{"name": ["append"], "description": ["Add an item to the end of the list; equivalent to a[len(a):] = [x]. "]},
{"name": ["extend"], "description": ["Extend the list by appending all the items in the given list; equivalent to a[len(a):] = L. "]},
{"name": ["insert"], "description": ["Insert an item at a given position.  The first argument is the index of the element before which to insert, so a.insert(0, x) inserts at the front of the list, and a.insert(len(a), x) is equivalent to a.append(x). "]},
{"name": ["remove"], "description": ["Remove the first item from the list whose value is x. It is an error if there is no such item. "]},
{"name": ["pop"], "description": ["Remove the item at the given position in the list, and return it.  If no index is specified, a.pop() removes and returns the last item in the list.  (The square brackets around the i in the method signature denote that the parameter is optional, not that you should type square brackets at that position.  You will see this notation frequently in the Python Library Reference.) "]},
{"name": ["index"], "description": ["Return the index in the list of the first item whose value is x. It is an error if there is no such item. "]},
{"name": ["count"], "description": ["Return the number of times x appears in the list. "]},
{"name": ["sort"], "description": ["Sort the items of the list in place (the arguments can be used for sort customization, see sorted() for their explanation). "]},
{"name": ["reverse"], "description": ["Reverse the elements of the list, in place. "]}];

chrome.extension.sendMessage({}, function(response) {
	var readyStateCheckInterval = setInterval(function() {
	if (document.readyState === "complete") {
		clearInterval(readyStateCheckInterval);

		// ----------------------------------------------------------
		// This part of the script triggers when page is done loading
		console.log("Hello. This message was sent from scripts/inject.js");
		// ----------------------------------------------------------

	}
	}, 10);
});

f = function(e) {
	var _query = window.getSelection().toString();
	console.log("query: " + _query + " len: " + _query.length);
	var _last_var_x = e.pageX - 100;
	var _last_var_y = e.pageY + 10;
	//console.log("x: " + _last_var_x + " y: " + _last_var_y);
	var _query_result = '';
	var _link = '';
	for(var i = 0; i < items.length; i++){
		//console.log(items[i].name[0]);
		if(items[i].name[0] == _query){
			var THE_CAGE = Math.random();
<<<<<<< HEAD
			// console.log(THE_CAGE);
			if (THE_CAGE < .51){document.body.style.backgroundImage="url('data:image/jpeg;base64,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')";}
				var _a = items[i].description[0].indexOf('.');
				_query_result = items[i].description[0];//.substring(0, _a);
				_link = "https://docs.python.org/2/library/functions.html#" + _query;
=======
			console.log(THE_CAGE);
			if (THE_CAGE < .51){document.body.style.backgroundImage="url('THE_CAGE.jpeg')";}
			
			var _a = items[i].description[0].indexOf('.');
			_query_result = items[i].description[0];//.substring(0, _a);
			_link = "https://docs.python.org/2/library/functions.html#" + _query;
			var test = '<div id="gdx-bubble-host">/* Copyright 2014 Google Inc. All Rights Reserved. */<div id="gdx-bubble-main" style="left: ' + _last_var_x + 'px; top: '+ _last_var_y + 'px;"><div id="gdx-bubble-query-row" class=""><div id="gdx-bubble-query">' + _query + '</div></div><div id="gdx-bubble-meaning">' + _query_result + '</div><div id="gdx-bubble-attribution" class="display-none"><a target="_blank"></a><div></div></div><div id="gdx-bubble-more" class=""><a target="_blank" href=' + _link + '>More </a></div></div><div></div></div>';
			$(document.body).append(test);
		}	
>>>>>>> FETCH_HEAD
	}

}
//removing boxes on click off
g = function(e) {
	$("#gdx-bubble-host").remove();
}

console.log(items);
var _last_var_x = 0;
var _last_var_y = 0;

document.body.addEventListener('dblclick', f);
$(document.body).click(g);


//id = gdx-bubble-main